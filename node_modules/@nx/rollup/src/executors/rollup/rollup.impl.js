"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRollupOptions = exports.rollupExecutor = void 0;
const tslib_1 = require("tslib");
require("dotenv/config");
const ts = require("typescript");
const rollup = require("rollup");
const peerDepsExternal = require("rollup-plugin-peer-deps-external");
const plugin_babel_1 = require("@rollup/plugin-babel");
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const rxjs_for_await_1 = require("@nx/devkit/src/utils/rxjs-for-await");
const autoprefixer = require("autoprefixer");
const devkit_1 = require("@nx/devkit");
const buildable_libs_utils_1 = require("@nx/js/src/utils/buildable-libs-utils");
const plugin_node_resolve_1 = require("@rollup/plugin-node-resolve");
const run_rollup_1 = require("./lib/run-rollup");
const normalize_1 = require("./lib/normalize");
const analyze_plugin_1 = require("./lib/analyze-plugin");
const fs_1 = require("../../utils/fs");
const swc_plugin_1 = require("./lib/swc-plugin");
const update_package_json_1 = require("./lib/update-package-json");
const type_definitions_1 = require("@nx/js/src/plugins/rollup/type-definitions");
// These use require because the ES import isn't correct.
const commonjs = require('@rollup/plugin-commonjs');
const image = require('@rollup/plugin-image');
const json = require('@rollup/plugin-json');
const copy = require('rollup-plugin-copy');
const postcss = require('rollup-plugin-postcss');
const fileExtensions = ['.js', '.jsx', '.ts', '.tsx'];
function rollupExecutor(rawOptions, context) {
    var _a, _b;
    var _c;
    return tslib_1.__asyncGenerator(this, arguments, function* rollupExecutor_1() {
        (_a = (_c = process.env).NODE_ENV) !== null && _a !== void 0 ? _a : (_c.NODE_ENV = 'production');
        const project = context.projectsConfigurations.projects[context.projectName];
        const sourceRoot = project.sourceRoot;
        const { target, dependencies } = (0, buildable_libs_utils_1.calculateProjectBuildableDependencies)(context.taskGraph, context.projectGraph, context.root, context.projectName, context.targetName, context.configurationName, true);
        const options = (0, normalize_1.normalizeRollupExecutorOptions)(rawOptions, context, sourceRoot);
        const packageJson = (0, devkit_1.readJsonFile)(options.project);
        const npmDeps = ((_b = context.projectGraph.dependencies[context.projectName]) !== null && _b !== void 0 ? _b : [])
            .filter((d) => d.target.startsWith('npm:'))
            .map((d) => d.target.slice(4));
        const rollupOptions = createRollupOptions(options, dependencies, context, packageJson, sourceRoot, npmDeps);
        const outfile = resolveOutfile(context, options);
        if (options.watch) {
            const watcher = rollup.watch(rollupOptions);
            return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues((0, rxjs_for_await_1.eachValueFrom)(new rxjs_1.Observable((obs) => {
                watcher.on('event', (data) => {
                    if (data.code === 'START') {
                        devkit_1.logger.info(`Bundling ${context.projectName}...`);
                    }
                    else if (data.code === 'END') {
                        (0, update_package_json_1.updatePackageJson)(options, context, target, dependencies, packageJson);
                        devkit_1.logger.info('Bundle complete. Watching for file changes...');
                        obs.next({ success: true, outfile });
                    }
                    else if (data.code === 'ERROR') {
                        devkit_1.logger.error(`Error during bundle: ${data.error.message}`);
                        obs.next({ success: false });
                    }
                });
                // Teardown logic. Close watcher when unsubscribed.
                return () => watcher.close();
            }))))));
        }
        else {
            devkit_1.logger.info(`Bundling ${context.projectName}...`);
            // Delete output path before bundling
            if (options.deleteOutputPath) {
                (0, fs_1.deleteOutputDir)(context.root, options.outputPath);
            }
            const start = process.hrtime.bigint();
            return yield tslib_1.__await((0, rxjs_1.from)(rollupOptions)
                .pipe((0, operators_1.concatMap)((opts) => (0, run_rollup_1.runRollup)(opts).pipe((0, operators_1.catchError)((e) => {
                devkit_1.logger.error(`Error during bundle: ${e}`);
                return (0, rxjs_1.of)({ success: false });
            }))), (0, operators_1.scan)((acc, result) => {
                if (!acc.success)
                    return acc;
                return result;
            }, { success: true, outfile }), (0, operators_1.last)(), (0, operators_1.tap)({
                next: (result) => {
                    if (result.success) {
                        const end = process.hrtime.bigint();
                        const duration = `${(Number(end - start) / 1000000000).toFixed(2)}s`;
                        (0, update_package_json_1.updatePackageJson)(options, context, target, dependencies, packageJson);
                        devkit_1.logger.info(`âš¡ Done in ${duration}`);
                    }
                    else {
                        devkit_1.logger.error(`Bundle failed: ${context.projectName}`);
                    }
                },
            }))
                .toPromise());
        }
    });
}
exports.rollupExecutor = rollupExecutor;
// -----------------------------------------------------------------------------
function createRollupOptions(options, dependencies, context, packageJson, sourceRoot, npmDeps) {
    const useBabel = options.compiler === 'babel';
    const useTsc = options.compiler === 'tsc';
    const useSwc = options.compiler === 'swc';
    const tsConfigPath = (0, devkit_1.joinPathFragments)(context.root, options.tsConfig);
    const configFile = ts.readConfigFile(tsConfigPath, ts.sys.readFile);
    const config = ts.parseJsonConfigFileContent(configFile.config, ts.sys, (0, path_1.dirname)(tsConfigPath));
    if (!options.format || !options.format.length) {
        options.format = readCompatibleFormats(config);
    }
    return options.format.map((format, idx) => {
        // Either we're generating only one format, so we should bundle types
        // OR we are generating dual formats, so only bundle types for CJS.
        const shouldBundleTypes = options.format.length === 1 || format === 'cjs';
        const plugins = [
            copy({
                targets: convertCopyAssetsToRollupOptions(options.outputPath, options.assets),
            }),
            image(),
            json(),
            (useTsc || shouldBundleTypes) &&
                require('rollup-plugin-typescript2')({
                    check: !options.skipTypeCheck,
                    tsconfig: options.tsConfig,
                    tsconfigOverride: {
                        compilerOptions: createTsCompilerOptions(config, dependencies, options),
                    },
                }),
            shouldBundleTypes &&
                (0, type_definitions_1.typeDefinitions)({
                    main: options.main,
                    projectRoot: options.projectRoot,
                }),
            peerDepsExternal({
                packageJsonPath: options.project,
            }),
            postcss({
                inject: true,
                extract: options.extractCss,
                autoModules: true,
                plugins: [autoprefixer],
                use: {
                    less: {
                        javascriptEnabled: options.javascriptEnabled,
                    },
                },
            }),
            (0, plugin_node_resolve_1.default)({
                preferBuiltins: true,
                extensions: fileExtensions,
            }),
            useSwc && (0, swc_plugin_1.swc)(),
            useBabel &&
                (0, plugin_babel_1.getBabelInputPlugin)({
                    // Lets `@nx/js/babel` preset know that we are packaging.
                    caller: {
                        // @ts-ignore
                        // Ignoring type checks for caller since we have custom attributes
                        isNxPackage: true,
                        // Always target esnext and let rollup handle cjs
                        supportsStaticESM: true,
                        isModern: true,
                    },
                    cwd: (0, path_1.join)(context.root, sourceRoot),
                    rootMode: options.babelUpwardRootMode ? 'upward' : undefined,
                    babelrc: true,
                    extensions: fileExtensions,
                    babelHelpers: 'bundled',
                    skipPreflightCheck: true,
                    exclude: /node_modules/,
                    plugins: [
                        format === 'esm'
                            ? undefined
                            : require.resolve('babel-plugin-transform-async-to-promises'),
                    ].filter(Boolean),
                }),
            commonjs(),
            (0, analyze_plugin_1.analyze)(),
        ];
        let externalPackages = [
            ...Object.keys(packageJson.dependencies || {}),
            ...Object.keys(packageJson.peerDependencies || {}),
        ]; // If external is set to none, include all dependencies and peerDependencies in externalPackages
        if (options.external === 'all') {
            externalPackages = externalPackages
                .concat(dependencies.map((d) => d.name))
                .concat(npmDeps);
        }
        else if (Array.isArray(options.external) && options.external.length > 0) {
            externalPackages = externalPackages.concat(options.external);
        }
        externalPackages = [...new Set(externalPackages)];
        const mainEntryFileName = options.outputFileName || options.main;
        const input = {};
        input[(0, path_1.parse)(mainEntryFileName).name] = options.main;
        options.additionalEntryPoints.forEach((entry) => {
            input[(0, path_1.parse)(entry).name] = entry;
        });
        const rollupConfig = {
            input,
            output: {
                format,
                dir: `${options.outputPath}`,
                name: (0, devkit_1.names)(context.projectName).className,
                entryFileNames: `[name].${format}.js`,
                chunkFileNames: `[name].${format}.js`,
            },
            external: (id) => {
                return externalPackages.some((name) => id === name || id.startsWith(`${name}/`)); // Could be a deep import
            },
            plugins,
        };
        return options.rollupConfig.reduce((currentConfig, plugin) => {
            return require(plugin)(currentConfig, options);
        }, rollupConfig);
    });
}
exports.createRollupOptions = createRollupOptions;
function createTsCompilerOptions(config, dependencies, options) {
    const compilerOptionPaths = (0, buildable_libs_utils_1.computeCompilerOptionsPaths)(config, dependencies);
    const compilerOptions = {
        rootDir: options.projectRoot,
        allowJs: options.allowJs,
        declaration: true,
        paths: compilerOptionPaths,
    };
    if (config.options.module === ts.ModuleKind.CommonJS) {
        compilerOptions['module'] = 'ESNext';
    }
    if (options.compiler === 'swc') {
        compilerOptions['emitDeclarationOnly'] = true;
    }
    return compilerOptions;
}
function convertCopyAssetsToRollupOptions(outputPath, assets) {
    return assets
        ? assets.map((a) => ({
            src: (0, path_1.join)(a.input, a.glob).replace(/\\/g, '/'),
            dest: (0, path_1.join)(outputPath, a.output).replace(/\\/g, '/'),
        }))
        : undefined;
}
function readCompatibleFormats(config) {
    switch (config.options.module) {
        case ts.ModuleKind.CommonJS:
        case ts.ModuleKind.UMD:
        case ts.ModuleKind.AMD:
            return ['cjs'];
        default:
            return ['esm'];
    }
}
function resolveOutfile(context, options) {
    var _a, _b;
    if (!((_a = options.format) === null || _a === void 0 ? void 0 : _a.includes('cjs')))
        return undefined;
    const { name } = (0, path_1.parse)((_b = options.outputFileName) !== null && _b !== void 0 ? _b : options.main);
    return (0, path_1.resolve)(context.root, options.outputPath, `${name}.cjs.js`);
}
exports.default = rollupExecutor;
