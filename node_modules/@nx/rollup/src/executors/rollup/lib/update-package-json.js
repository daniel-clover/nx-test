"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePackageJson = void 0;
const path_1 = require("path");
const buildable_libs_utils_1 = require("@nx/js/src/utils/buildable-libs-utils");
const fileutils_1 = require("nx/src/utils/fileutils");
// TODO(jack): Use updatePackageJson from @nx/js instead.
function updatePackageJson(options, context, target, dependencies, packageJson) {
    var _a, _b;
    var _c;
    const hasEsmFormat = options.format.includes('esm');
    const hasCjsFormat = options.format.includes('cjs');
    if (options.generateExportsField) {
        packageJson.exports =
            typeof packageJson.exports === 'string' ? {} : Object.assign({}, packageJson.exports);
        packageJson.exports['./package.json'] = './package.json';
    }
    if (hasEsmFormat) {
        const esmExports = getExports(Object.assign(Object.assign({}, options), { fileExt: '.esm.js' }));
        packageJson.module = esmExports['.'];
        if (!hasCjsFormat) {
            packageJson.type = 'module';
            (_a = packageJson.main) !== null && _a !== void 0 ? _a : (packageJson.main = esmExports['.']);
        }
        if (options.generateExportsField) {
            for (const [exportEntry, filePath] of Object.entries(esmExports)) {
                packageJson.exports[exportEntry] = hasCjsFormat
                    ? { import: filePath }
                    : filePath;
            }
        }
    }
    if (hasCjsFormat) {
        const cjsExports = getExports(Object.assign(Object.assign({}, options), { fileExt: '.cjs.js' }));
        packageJson.main = cjsExports['.'];
        if (!hasEsmFormat) {
            packageJson.type = 'commonjs';
        }
        if (options.generateExportsField) {
            for (const [exportEntry, filePath] of Object.entries(cjsExports)) {
                if (hasEsmFormat) {
                    (_b = (_c = packageJson.exports[exportEntry])['default']) !== null && _b !== void 0 ? _b : (_c['default'] = filePath);
                }
                else {
                    packageJson.exports[exportEntry] = filePath;
                }
            }
        }
    }
    (0, fileutils_1.writeJsonFile)(`${options.outputPath}/package.json`, packageJson);
    if (dependencies.length > 0 &&
        options.updateBuildableProjectDepsInPackageJson) {
        (0, buildable_libs_utils_1.updateBuildableProjectPackageJsonDependencies)(context.root, context.projectName, context.targetName, context.configurationName, target, dependencies, options.buildableProjectDepsInPackageJsonType);
    }
}
exports.updatePackageJson = updatePackageJson;
function getExports(options) {
    const mainFile = options.outputFileName
        ? options.outputFileName.replace(/\.[tj]s$/, '')
        : (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
    const exports = {
        '.': './' + mainFile + options.fileExt,
    };
    if (options.additionalEntryPoints) {
        for (const file of options.additionalEntryPoints) {
            const { name: fileName } = (0, path_1.parse)(file);
            exports['./' + fileName] = './' + fileName + options.fileExt;
        }
    }
    return exports;
}
