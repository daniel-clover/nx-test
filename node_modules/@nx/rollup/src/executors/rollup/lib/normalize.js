"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeAssets = exports.normalizePluginPath = exports.normalizeRollupExecutorOptions = void 0;
const path_1 = require("path");
const fast_glob_1 = require("fast-glob");
const fs_1 = require("fs");
const devkit_1 = require("@nx/devkit");
function normalizeRollupExecutorOptions(options, context, sourceRoot) {
    const { root } = context;
    const main = `${root}/${options.main}`;
    const entryRoot = (0, path_1.dirname)(main);
    const project = options.project
        ? `${root}/${options.project}`
        : (0, path_1.join)(root, 'package.json');
    const projectRoot = (0, path_1.dirname)(project);
    const outputPath = `${root}/${options.outputPath}`;
    if (options.buildableProjectDepsInPackageJsonType == undefined) {
        options.buildableProjectDepsInPackageJsonType = 'peerDependencies';
    }
    return Object.assign(Object.assign({}, options), { 
        // de-dupe formats
        format: Array.from(new Set(options.format)), rollupConfig: []
            .concat(options.rollupConfig)
            .filter(Boolean)
            .map((p) => normalizePluginPath(p, root)), assets: options.assets
            ? normalizeAssets(options.assets, root, sourceRoot)
            : undefined, main,
        entryRoot,
        project,
        projectRoot,
        outputPath, skipTypeCheck: options.skipTypeCheck || false, additionalEntryPoints: createEntryPoints(options, context) });
}
exports.normalizeRollupExecutorOptions = normalizeRollupExecutorOptions;
function normalizePluginPath(pluginPath, root) {
    if (!pluginPath) {
        return '';
    }
    try {
        return require.resolve(pluginPath);
    }
    catch (_a) {
        return (0, path_1.resolve)(root, pluginPath);
    }
}
exports.normalizePluginPath = normalizePluginPath;
function normalizeAssets(assets, root, sourceRoot) {
    return assets.map((asset) => {
        if (typeof asset === 'string') {
            const assetPath = (0, devkit_1.normalizePath)(asset);
            const resolvedAssetPath = (0, path_1.resolve)(root, assetPath);
            const resolvedSourceRoot = (0, path_1.resolve)(root, sourceRoot);
            if (!resolvedAssetPath.startsWith(resolvedSourceRoot)) {
                throw new Error(`The ${resolvedAssetPath} asset path must start with the project source root: ${sourceRoot}`);
            }
            const isDirectory = (0, fs_1.statSync)(resolvedAssetPath).isDirectory();
            const input = isDirectory
                ? resolvedAssetPath
                : (0, path_1.dirname)(resolvedAssetPath);
            const output = (0, path_1.relative)(resolvedSourceRoot, (0, path_1.resolve)(root, input));
            const glob = isDirectory ? '**/*' : (0, path_1.basename)(resolvedAssetPath);
            return {
                input,
                output,
                glob,
            };
        }
        else {
            if (asset.output.startsWith('..')) {
                throw new Error('An asset cannot be written to a location outside of the output path.');
            }
            const assetPath = (0, devkit_1.normalizePath)(asset.input);
            const resolvedAssetPath = (0, path_1.resolve)(root, assetPath);
            return Object.assign(Object.assign({}, asset), { input: resolvedAssetPath, 
                // Now we remove starting slash to make Webpack place it from the output root.
                output: asset.output.replace(/^\//, '') });
        }
    });
}
exports.normalizeAssets = normalizeAssets;
function createEntryPoints(options, context) {
    var _a;
    if (!((_a = options.additionalEntryPoints) === null || _a === void 0 ? void 0 : _a.length))
        return [];
    return (0, fast_glob_1.sync)(options.additionalEntryPoints, {
        cwd: context.root,
    });
}
