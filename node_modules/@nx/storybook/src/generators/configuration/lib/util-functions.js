"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renameAndMoveOldTsConfig = exports.getViteConfigFilePath = exports.getE2EProjectName = exports.rootFileIsTs = exports.workspaceHasRootProject = exports.projectIsRootProjectInStandaloneWorkspace = exports.addBuildStorybookToCacheableOperations = exports.getTsConfigPath = exports.createProjectStorybookDir = exports.addStorybookToNamedInputs = exports.normalizeSchema = exports.updateLintConfig = exports.configureTsSolutionConfig = exports.configureTsProjectConfig = exports.editTsconfigBaseJson = exports.createStorybookTsconfigFile = exports.addStaticTarget = exports.addAngularStorybookTask = exports.addStorybookTask = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const executor_options_utils_1 = require("@nx/devkit/src/generators/executor-options-utils");
const linter_1 = require("@nx/linter");
const path_1 = require("path");
const utilities_1 = require("../../../utils/utilities");
const versions_1 = require("../../../utils/versions");
const DEFAULT_PORT = 4400;
function addStorybookTask(tree, projectName, uiFramework, interactionTests) {
    if (uiFramework === '@storybook/react-native') {
        return;
    }
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    projectConfig.targets['storybook'] = {
        executor: '@nx/storybook:storybook',
        options: {
            port: DEFAULT_PORT,
            configDir: `${projectConfig.root}/.storybook`,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    projectConfig.targets['build-storybook'] = {
        executor: '@nx/storybook:build',
        outputs: ['{options.outputDir}'],
        options: {
            outputDir: (0, devkit_1.joinPathFragments)('dist/storybook', projectName),
            configDir: `${projectConfig.root}/.storybook`,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    if (interactionTests === true) {
        projectConfig.targets['test-storybook'] = {
            executor: 'nx:run-commands',
            options: {
                command: `test-storybook -c ${projectConfig.root}/.storybook --url=http://localhost:${DEFAULT_PORT}`,
            },
        };
    }
    (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
}
exports.addStorybookTask = addStorybookTask;
function addAngularStorybookTask(tree, projectName, interactionTests) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const { ngBuildTarget } = (0, utilities_1.findStorybookAndBuildTargetsAndCompiler)(projectConfig.targets);
    projectConfig.targets['storybook'] = {
        executor: '@storybook/angular:start-storybook',
        options: {
            port: 4400,
            configDir: `${projectConfig.root}/.storybook`,
            browserTarget: `${projectName}:${ngBuildTarget ? 'build' : 'build-storybook'}`,
            compodoc: false,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    projectConfig.targets['build-storybook'] = {
        executor: '@storybook/angular:build-storybook',
        outputs: ['{options.outputDir}'],
        options: {
            outputDir: (0, devkit_1.joinPathFragments)('dist/storybook', projectName),
            configDir: `${projectConfig.root}/.storybook`,
            browserTarget: `${projectName}:${ngBuildTarget ? 'build' : 'build-storybook'}`,
            compodoc: false,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    if (interactionTests === true) {
        projectConfig.targets['test-storybook'] = {
            executor: 'nx:run-commands',
            options: {
                command: `test-storybook -c ${projectConfig.root}/.storybook --url=http://localhost:${DEFAULT_PORT}`,
            },
        };
    }
    (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
}
exports.addAngularStorybookTask = addAngularStorybookTask;
function addStaticTarget(tree, opts) {
    const nrwlWeb = (0, devkit_1.ensurePackage)('@nx/web', versions_1.nxVersion);
    nrwlWeb.webStaticServeGenerator(tree, {
        buildTarget: `${opts.name}:build-storybook`,
        outputPath: (0, devkit_1.joinPathFragments)('dist/storybook', opts.name),
        targetName: 'static-storybook',
    });
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, opts.name);
    projectConfig.targets['static-storybook'].configurations = {
        ci: {
            buildTarget: `${opts.name}:build-storybook:ci`,
        },
    };
    (0, devkit_1.updateProjectConfiguration)(tree, opts.name, projectConfig);
}
exports.addStaticTarget = addStaticTarget;
function createStorybookTsconfigFile(tree, projectRoot, uiFramework, isRootProject, mainDir) {
    // First let's check if old configuration file exists
    // If it exists, let's rename it and move it to the new location
    const oldStorybookTsConfigPath = (0, devkit_1.joinPathFragments)(projectRoot, '.storybook/tsconfig.json');
    if (tree.exists(oldStorybookTsConfigPath)) {
        devkit_1.logger.warn(`.storybook/tsconfig.json already exists for this project`);
        devkit_1.logger.warn(`It will be renamed and moved to tsconfig.storybook.json. 
      Please make sure all settings look correct after this change.
      Also, please make sure to use "nx migrate" to move from one version of Nx to another.
      `);
        renameAndMoveOldTsConfig(projectRoot, oldStorybookTsConfigPath, tree);
        return;
    }
    const storybookTsConfigPath = (0, devkit_1.joinPathFragments)(projectRoot, 'tsconfig.storybook.json');
    if (tree.exists(storybookTsConfigPath)) {
        devkit_1.logger.info(`tsconfig.storybook.json already exists for this project`);
        return;
    }
    const exclude = [`${mainDir}/**/*.spec.ts`, `${mainDir}/**/*.test.ts`];
    if (uiFramework === '@storybook/react-webpack5' ||
        uiFramework === '@storybook/react-vite') {
        exclude.push(`${mainDir}/**/*.spec.js`, `${mainDir}/**/*.test.js`, `${mainDir}/**/*.spec.tsx`, `${mainDir}/**/*.test.tsx`, `${mainDir}/**/*.spec.jsx`, `${mainDir}/**/*.test.js`);
    }
    let files;
    if (uiFramework === '@storybook/react-webpack5' ||
        uiFramework === '@storybook/react-vite') {
        const offset = (0, devkit_1.offsetFromRoot)(projectRoot);
        files = [
            `${!isRootProject ? offset : ''}node_modules/@nx/react/typings/styled-jsx.d.ts`,
            `${!isRootProject ? offset : ''}node_modules/@nx/react/typings/cssmodule.d.ts`,
            `${!isRootProject ? offset : ''}node_modules/@nx/react/typings/image.d.ts`,
        ];
    }
    const include = [
        `${mainDir}/**/*.stories.ts`,
        `${mainDir}/**/*.stories.js`,
        `${mainDir}/**/*.stories.jsx`,
        `${mainDir}/**/*.stories.tsx`,
        `${mainDir}/**/*.stories.mdx`,
        '.storybook/*.js',
        '.storybook/*.ts',
    ];
    if (uiFramework === '@storybook/react-native') {
        include.push('*.ts', '*.tsx');
    }
    const storybookTsConfig = {
        extends: './tsconfig.json',
        compilerOptions: {
            emitDecoratorMetadata: true,
            outDir: uiFramework === '@storybook/react-webpack5' ||
                uiFramework === '@storybook/react-vite'
                ? ''
                : undefined,
        },
        files,
        exclude,
        include,
    };
    (0, devkit_1.writeJson)(tree, storybookTsConfigPath, storybookTsConfig);
}
exports.createStorybookTsconfigFile = createStorybookTsconfigFile;
function editTsconfigBaseJson(tree) {
    let tsconfigBasePath = 'tsconfig.base.json';
    // standalone workspace maybe
    if (!tree.exists(tsconfigBasePath))
        tsconfigBasePath = 'tsconfig.json';
    if (!tree.exists(tsconfigBasePath))
        return;
    const tsconfigBaseContent = (0, devkit_1.readJson)(tree, tsconfigBasePath);
    if (!tsconfigBaseContent.compilerOptions)
        tsconfigBaseContent.compilerOptions = {};
    tsconfigBaseContent.compilerOptions.skipLibCheck = true;
    (0, devkit_1.writeJson)(tree, tsconfigBasePath, tsconfigBaseContent);
}
exports.editTsconfigBaseJson = editTsconfigBaseJson;
function configureTsProjectConfig(tree, schema) {
    var _a, _b, _c;
    const { name: projectName } = schema;
    let tsConfigPath;
    let tsConfigContent;
    try {
        tsConfigPath = getTsConfigPath(tree, projectName);
        tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    }
    catch (_d) {
        /**
         * Custom app configurations
         * may contain a tsconfig.json
         * instead of a tsconfig.app.json.
         */
        tsConfigPath = getTsConfigPath(tree, projectName, 'tsconfig.json');
        tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    }
    if (!((_a = tsConfigContent === null || tsConfigContent === void 0 ? void 0 : tsConfigContent.exclude) === null || _a === void 0 ? void 0 : _a.includes('**/*.stories.ts')) &&
        !((_b = tsConfigContent === null || tsConfigContent === void 0 ? void 0 : tsConfigContent.exclude) === null || _b === void 0 ? void 0 : _b.includes('**/*.stories.js'))) {
        tsConfigContent.exclude = [
            ...(tsConfigContent.exclude || []),
            '**/*.stories.ts',
            '**/*.stories.js',
            ...(schema.uiFramework === '@storybook/react-native' ||
                ((_c = schema.uiFramework) === null || _c === void 0 ? void 0 : _c.startsWith('@storybook/react'))
                ? ['**/*.stories.jsx', '**/*.stories.tsx']
                : []),
        ];
    }
    (0, devkit_1.writeJson)(tree, tsConfigPath, tsConfigContent);
}
exports.configureTsProjectConfig = configureTsProjectConfig;
function configureTsSolutionConfig(tree, schema) {
    var _a, _b, _c, _d;
    const { name: projectName } = schema;
    const { root } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const tsConfigPath = (0, path_1.join)(root, 'tsconfig.json');
    const tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    if (schema.uiFramework === '@storybook/angular') {
        if (!((_b = (_a = tsConfigContent.references) === null || _a === void 0 ? void 0 : _a.map((reference) => reference.path)) === null || _b === void 0 ? void 0 : _b.includes('./.storybook/tsconfig.json'))) {
            tsConfigContent.references = [
                ...(tsConfigContent.references || []),
                {
                    path: './.storybook/tsconfig.json',
                },
            ];
        }
    }
    else {
        if (!((_d = (_c = tsConfigContent.references) === null || _c === void 0 ? void 0 : _c.map((reference) => reference.path)) === null || _d === void 0 ? void 0 : _d.includes('./tsconfig.storybook.json'))) {
            tsConfigContent.references = [
                ...(tsConfigContent.references || []),
                {
                    path: './tsconfig.storybook.json',
                },
            ];
        }
    }
    (0, devkit_1.writeJson)(tree, tsConfigPath, tsConfigContent);
}
exports.configureTsSolutionConfig = configureTsSolutionConfig;
/**
 * When adding storybook we need to inform TSLint or ESLint
 * of the additional tsconfig.json file which will be the only tsconfig
 * which includes *.stories files.
 *
 * For TSLint this is done via the builder config, for ESLint this is
 * done within the .eslintrc.json file.
 */
function updateLintConfig(tree, schema) {
    const { name: projectName } = schema;
    const { targets, root } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const tslintTargets = Object.values(targets).filter((target) => target.executor === '@angular-devkit/build-angular:tslint');
    tslintTargets.forEach((target) => {
        target.options.tsConfig = (0, utilities_1.dedupe)([
            ...target.options.tsConfig,
            (0, devkit_1.joinPathFragments)(root, './.storybook/tsconfig.json'),
        ]);
    });
    if (tree.exists((0, path_1.join)(root, '.eslintrc.json'))) {
        (0, devkit_1.updateJson)(tree, (0, path_1.join)(root, '.eslintrc.json'), (json) => {
            var _a, _b, _c, _d;
            if (typeof ((_a = json.parserOptions) === null || _a === void 0 ? void 0 : _a.project) === 'string') {
                json.parserOptions.project = [json.parserOptions.project];
            }
            if (Array.isArray((_b = json.parserOptions) === null || _b === void 0 ? void 0 : _b.project)) {
                json.parserOptions.project = (0, utilities_1.dedupe)([
                    ...json.parserOptions.project,
                    schema.uiFramework === '@storybook/angular'
                        ? (0, path_1.join)(root, '.storybook/tsconfig.json')
                        : (0, path_1.join)(root, 'tsconfig.storybook.json'),
                ]);
            }
            const overrides = json.overrides || [];
            for (const o of overrides) {
                if (typeof ((_c = o.parserOptions) === null || _c === void 0 ? void 0 : _c.project) === 'string') {
                    o.parserOptions.project = [o.parserOptions.project];
                }
                if (Array.isArray((_d = o.parserOptions) === null || _d === void 0 ? void 0 : _d.project)) {
                    o.parserOptions.project = (0, utilities_1.dedupe)([
                        ...o.parserOptions.project,
                        schema.uiFramework === '@storybook/angular'
                            ? (0, path_1.join)(root, '.storybook/tsconfig.json')
                            : (0, path_1.join)(root, 'tsconfig.storybook.json'),
                    ]);
                }
            }
            return json;
        });
    }
}
exports.updateLintConfig = updateLintConfig;
function normalizeSchema(schema) {
    const defaults = {
        configureCypress: true,
        linter: linter_1.Linter.EsLint,
        js: false,
    };
    return Object.assign(Object.assign({}, defaults), schema);
}
exports.normalizeSchema = normalizeSchema;
function addStorybookToNamedInputs(tree) {
    var _a, _b, _c, _d;
    var _e, _f;
    const nxJson = (0, devkit_1.readNxJson)(tree);
    if (nxJson.namedInputs) {
        const hasProductionFileset = !!((_a = nxJson.namedInputs) === null || _a === void 0 ? void 0 : _a.production);
        if (hasProductionFileset) {
            if (!nxJson.namedInputs.production.includes('!{projectRoot}/**/*.stories.@(js|jsx|ts|tsx|mdx)')) {
                nxJson.namedInputs.production.push('!{projectRoot}/**/*.stories.@(js|jsx|ts|tsx|mdx)');
            }
            if (!nxJson.namedInputs.production.includes('!{projectRoot}/.storybook/**/*')) {
                nxJson.namedInputs.production.push('!{projectRoot}/.storybook/**/*');
            }
            if (!nxJson.namedInputs.production.includes('!{projectRoot}/tsconfig.storybook.json')) {
                nxJson.namedInputs.production.push('!{projectRoot}/tsconfig.storybook.json');
            }
        }
        (_b = nxJson.targetDefaults) !== null && _b !== void 0 ? _b : (nxJson.targetDefaults = {});
        (_c = (_e = nxJson.targetDefaults)['build-storybook']) !== null && _c !== void 0 ? _c : (_e['build-storybook'] = {});
        (_d = (_f = nxJson.targetDefaults['build-storybook']).inputs) !== null && _d !== void 0 ? _d : (_f.inputs = [
            'default',
            hasProductionFileset ? '^production' : '^default',
        ]);
        if (!nxJson.targetDefaults['build-storybook'].inputs.includes('{projectRoot}/.storybook/**/*')) {
            nxJson.targetDefaults['build-storybook'].inputs.push('{projectRoot}/.storybook/**/*');
        }
        // Delete the !{projectRoot}/.storybook/**/* glob from build-storybook
        // because we want to rebuild Storybook if the .storybook folder changes
        const index = nxJson.targetDefaults['build-storybook'].inputs.indexOf('!{projectRoot}/.storybook/**/*');
        if (index !== -1) {
            nxJson.targetDefaults['build-storybook'].inputs.splice(index, 1);
        }
        if (!nxJson.targetDefaults['build-storybook'].inputs.includes('{projectRoot}/tsconfig.storybook.json')) {
            nxJson.targetDefaults['build-storybook'].inputs.push('{projectRoot}/tsconfig.storybook.json');
        }
        (0, devkit_1.updateNxJson)(tree, nxJson);
    }
}
exports.addStorybookToNamedInputs = addStorybookToNamedInputs;
function createProjectStorybookDir(tree, projectName, uiFramework, js, tsConfiguration, root, projectType, projectIsRootProjectInStandaloneWorkspace, interactionTests, mainDir, isNextJs, usesSwc, usesVite, viteConfigFilePath) {
    const projectDirectory = projectType === 'application'
        ? isNextJs
            ? 'components'
            : 'src/app'
        : 'src/lib';
    const storybookConfigExists = projectIsRootProjectInStandaloneWorkspace
        ? tree.exists('.storybook/main.js') || tree.exists('.storybook/main.ts')
        : tree.exists((0, path_1.join)(root, '.storybook/main.ts')) ||
            tree.exists((0, path_1.join)(root, '.storybook/main.js'));
    if (storybookConfigExists) {
        devkit_1.logger.warn(`Storybook configuration files already exist for ${projectName}!`);
        return;
    }
    const templatePath = (0, path_1.join)(__dirname, `../project-files${tsConfiguration ? '-ts' : ''}`);
    (0, devkit_1.generateFiles)(tree, templatePath, root, {
        tmpl: '',
        uiFramework,
        offsetFromRoot: (0, devkit_1.offsetFromRoot)(root),
        projectDirectory,
        projectType,
        interactionTests,
        mainDir,
        isNextJs: isNextJs && projectType === 'application',
        usesSwc,
        usesVite,
        isRootProject: projectIsRootProjectInStandaloneWorkspace,
        viteConfigFilePath,
    });
    if (js) {
        (0, devkit_1.toJS)(tree);
    }
    if (uiFramework !== '@storybook/angular') {
        // This file is only used for Angular
        // For non-Angular projects, we generate a file
        // called tsconfig.storybook.json at the root of the project
        // using the createStorybookTsconfigFile function
        // since Storybook is only taking into account .storybook/tsconfig.json
        // for Angular projects
        tree.delete((0, path_1.join)(root, '.storybook/tsconfig.json'));
    }
}
exports.createProjectStorybookDir = createProjectStorybookDir;
function getTsConfigPath(tree, projectName, path) {
    const { root, projectType } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    return (0, path_1.join)(root, (path === null || path === void 0 ? void 0 : path.length) > 0
        ? path
        : projectType === 'application'
            ? 'tsconfig.app.json'
            : 'tsconfig.lib.json');
}
exports.getTsConfigPath = getTsConfigPath;
function addBuildStorybookToCacheableOperations(tree) {
    (0, devkit_1.updateJson)(tree, 'nx.json', (json) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        return (Object.assign(Object.assign({}, json), { tasksRunnerOptions: Object.assign(Object.assign({}, ((_a = json.tasksRunnerOptions) !== null && _a !== void 0 ? _a : {})), { default: Object.assign(Object.assign({}, ((_c = (_b = json.tasksRunnerOptions) === null || _b === void 0 ? void 0 : _b.default) !== null && _c !== void 0 ? _c : {})), { options: Object.assign(Object.assign({}, ((_f = (_e = (_d = json.tasksRunnerOptions) === null || _d === void 0 ? void 0 : _d.default) === null || _e === void 0 ? void 0 : _e.options) !== null && _f !== void 0 ? _f : {})), { cacheableOperations: Array.from(new Set([
                            ...((_k = (_j = (_h = (_g = json.tasksRunnerOptions) === null || _g === void 0 ? void 0 : _g.default) === null || _h === void 0 ? void 0 : _h.options) === null || _j === void 0 ? void 0 : _j.cacheableOperations) !== null && _k !== void 0 ? _k : []),
                            'build-storybook',
                        ])) }) }) }) }));
    });
}
exports.addBuildStorybookToCacheableOperations = addBuildStorybookToCacheableOperations;
function projectIsRootProjectInStandaloneWorkspace(projectRoot) {
    var _a;
    return ((_a = (0, path_1.relative)(devkit_1.workspaceRoot, projectRoot)) === null || _a === void 0 ? void 0 : _a.length) === 0;
}
exports.projectIsRootProjectInStandaloneWorkspace = projectIsRootProjectInStandaloneWorkspace;
function workspaceHasRootProject(tree) {
    return tree.exists('project.json');
}
exports.workspaceHasRootProject = workspaceHasRootProject;
function rootFileIsTs(tree, rootFileName, tsConfiguration) {
    if (tree.exists(`.storybook/${rootFileName}.ts`) && !tsConfiguration) {
        devkit_1.logger.info(`The root Storybook configuration is in TypeScript, 
      so Nx will generate TypeScript Storybook configuration files 
      in this project's .storybook folder as well.`);
        return true;
    }
    else if (tree.exists(`.storybook/${rootFileName}.js`) && tsConfiguration) {
        devkit_1.logger.info(`The root Storybook configuration is in JavaScript, 
        so Nx will generate JavaScript Storybook configuration files 
        in this project's .storybook folder as well.`);
        return false;
    }
    else {
        return tsConfiguration;
    }
}
exports.rootFileIsTs = rootFileIsTs;
function getE2EProjectName(tree, mainProject) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let e2eProject;
        const graph = yield (0, devkit_1.createProjectGraphAsync)();
        (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@nx/cypress:cypress', (options, projectName) => {
            if (e2eProject) {
                return;
            }
            if (options['devServerTarget']) {
                const { project, target } = (0, devkit_1.parseTargetString)(options['devServerTarget'], graph);
                if ((project === mainProject && target === 'serve') ||
                    (project === mainProject && target === 'storybook')) {
                    e2eProject = projectName;
                }
            }
        });
        return e2eProject;
    });
}
exports.getE2EProjectName = getE2EProjectName;
function getViteConfigFilePath(tree, projectRoot, configFile) {
    return configFile && tree.exists(configFile)
        ? configFile
        : tree.exists((0, devkit_1.joinPathFragments)(`${projectRoot}/vite.config.ts`))
            ? (0, devkit_1.joinPathFragments)(`${projectRoot}/vite.config.ts`)
            : tree.exists((0, devkit_1.joinPathFragments)(`${projectRoot}/vite.config.js`))
                ? (0, devkit_1.joinPathFragments)(`${projectRoot}/vite.config.js`)
                : undefined;
}
exports.getViteConfigFilePath = getViteConfigFilePath;
function renameAndMoveOldTsConfig(projectRoot, pathToStorybookConfigFile, tree) {
    if (pathToStorybookConfigFile && tree.exists(pathToStorybookConfigFile)) {
        (0, devkit_1.updateJson)(tree, pathToStorybookConfigFile, (json) => {
            var _a, _b, _c, _d;
            if ((_a = json.extends) === null || _a === void 0 ? void 0 : _a.startsWith('../')) {
                // drop one level of nesting
                json.extends = json.extends.replace('../', './');
            }
            for (let i = 0; i < ((_b = json.files) === null || _b === void 0 ? void 0 : _b.length); i++) {
                // drop one level of nesting
                if (json.files[i].startsWith('../../../')) {
                    json.files[i] = json.files[i].replace('../../../', '../../');
                }
            }
            for (let i = 0; i < ((_c = json.include) === null || _c === void 0 ? void 0 : _c.length); i++) {
                if (json.include[i].startsWith('../')) {
                    json.include[i] = json.include[i].replace('../', '');
                }
                if (json.include[i] === '*.js') {
                    json.include[i] = '.storybook/*.js';
                }
                if (json.include[i] === '*.ts') {
                    json.include[i] = '.storybook/*.ts';
                }
            }
            for (let i = 0; i < ((_d = json.exclude) === null || _d === void 0 ? void 0 : _d.length); i++) {
                if (json.exclude[i].startsWith('../')) {
                    json.exclude[i] = json.exclude[i].replace('../', 'src/');
                }
            }
            return json;
        });
        tree.rename(pathToStorybookConfigFile, (0, devkit_1.joinPathFragments)(projectRoot, `tsconfig.storybook.json`));
    }
    const projectTsConfig = (0, devkit_1.joinPathFragments)(projectRoot, 'tsconfig.json');
    if (tree.exists(projectTsConfig)) {
        (0, devkit_1.updateJson)(tree, projectTsConfig, (json) => {
            var _a;
            for (let i = 0; i < ((_a = json.references) === null || _a === void 0 ? void 0 : _a.length); i++) {
                if (json.references[i].path === './.storybook/tsconfig.json') {
                    json.references[i].path = './tsconfig.storybook.json';
                    break;
                }
            }
            return json;
        });
    }
    const projectEsLintFile = (0, devkit_1.joinPathFragments)(projectRoot, '.eslintrc.json');
    if (tree.exists(projectEsLintFile)) {
        (0, devkit_1.updateJson)(tree, projectEsLintFile, (json) => {
            const jsonString = JSON.stringify(json);
            const newJsonString = jsonString.replace(/\.storybook\/tsconfig\.json/g, 'tsconfig.storybook.json');
            json = JSON.parse(newJsonString);
            return json;
        });
    }
}
exports.renameAndMoveOldTsConfig = renameAndMoveOldTsConfig;
