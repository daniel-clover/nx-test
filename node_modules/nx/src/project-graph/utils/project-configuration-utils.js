"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readTargetDefaultsForTarget = exports.resolveNxTokensInOptions = exports.mergeTargetConfigurations = exports.buildProjectsConfigurationsFromProjectPathsAndPlugins = exports.mergeProjectConfigurationIntoProjectsConfigurations = void 0;
const tslib_1 = require("tslib");
const node_path_1 = require("node:path");
const package_json_workspaces_1 = require("../../../plugins/package-json-workspaces");
const project_json_1 = require("../../../plugins/project-json");
const logger_1 = require("../../utils/logger");
const workspace_root_1 = require("../../utils/workspace-root");
const minimatch = require("minimatch");
function mergeProjectConfigurationIntoProjectsConfigurations(
// projectName -> ProjectConfiguration
existingProjects, 
// projectRoot -> projectName
existingProjectRootMap, project, 
// project.json is a special case, so we need to detect it.
file) {
    let matchingProjectName = existingProjectRootMap.get(project.root);
    if (!matchingProjectName) {
        existingProjects[project.name] = project;
        existingProjectRootMap.set(project.root, project.name);
        return;
        // There are some special cases for handling project.json - mainly
        // that it should override any name the project already has.
    }
    else if (project.name &&
        project.name !== matchingProjectName &&
        (0, node_path_1.basename)(file) === 'project.json') {
        // Copy config to new name
        existingProjects[project.name] = existingProjects[matchingProjectName];
        // Update name in project config
        existingProjects[project.name].name = project.name;
        // Update root map to point to new name
        existingProjectRootMap[project.root] = project.name;
        // Remove entry for old name
        delete existingProjects[matchingProjectName];
        // Update name that config should be merged to
        matchingProjectName = project.name;
    }
    const matchingProject = existingProjects[matchingProjectName];
    // This handles top level properties that are overwritten. `srcRoot`, `projectType`, or fields that Nx doesn't know about.
    const updatedProjectConfiguration = Object.assign(Object.assign(Object.assign({}, matchingProject), project), { name: matchingProjectName });
    // The next blocks handle properties that should be themselves merged (e.g. targets, tags, and implicit dependencies)
    if (project.tags && matchingProject.tags) {
        updatedProjectConfiguration.tags = matchingProject.tags.concat(project.tags);
    }
    if (project.implicitDependencies && matchingProject.tags) {
        updatedProjectConfiguration.implicitDependencies =
            matchingProject.implicitDependencies.concat(project.implicitDependencies);
    }
    if (project.generators && matchingProject.generators) {
        updatedProjectConfiguration.generators = Object.assign(Object.assign({}, matchingProject.generators), project.generators);
    }
    if (project.targets && matchingProject.targets) {
        updatedProjectConfiguration.targets = Object.assign(Object.assign({}, matchingProject.targets), project.targets);
    }
    if (updatedProjectConfiguration.name !== matchingProject.name) {
        delete existingProjects[matchingProject.name];
    }
    existingProjects[updatedProjectConfiguration.name] =
        updatedProjectConfiguration;
}
exports.mergeProjectConfigurationIntoProjectsConfigurations = mergeProjectConfigurationIntoProjectsConfigurations;
function buildProjectsConfigurationsFromProjectPathsAndPlugins(nxJson, projectFiles, // making this parameter allows devkit to pick up newly created projects
plugins, root = workspace_root_1.workspaceRoot) {
    var _a;
    const projectRootMap = new Map();
    const projects = {};
    const externalNodes = {};
    // We push the nx core node builder onto the end, s.t. it overwrites any user specified behavior
    plugins.push((0, package_json_workspaces_1.getNxPackageJsonWorkspacesPlugin)(root), (0, project_json_1.getNxProjectJsonPlugin)(root));
    // We iterate over plugins first - this ensures that plugins specified first take precedence.
    for (const plugin of plugins) {
        const [pattern, configurationConstructor] = (_a = plugin.createNodes) !== null && _a !== void 0 ? _a : [];
        if (!pattern) {
            continue;
        }
        for (const file of projectFiles) {
            if (minimatch(file, pattern)) {
                const { projects: projectNodes, externalNodes: pluginExternalNodes } = configurationConstructor(file, {
                    projectsConfigurations: projects,
                    nxJsonConfiguration: nxJson,
                    workspaceRoot: root,
                });
                for (const node in projectNodes) {
                    mergeProjectConfigurationIntoProjectsConfigurations(projects, projectRootMap, projectNodes[node], file);
                }
                Object.assign(externalNodes, pluginExternalNodes);
            }
        }
    }
    return { projects, externalNodes };
}
exports.buildProjectsConfigurationsFromProjectPathsAndPlugins = buildProjectsConfigurationsFromProjectPathsAndPlugins;
function mergeTargetConfigurations(projectConfiguration, target, targetDefaults) {
    var _a;
    const targetConfiguration = (_a = projectConfiguration.targets) === null || _a === void 0 ? void 0 : _a[target];
    if (!targetConfiguration) {
        throw new Error(`Attempted to merge targetDefaults for ${projectConfiguration.name}.${target}, which doesn't exist.`);
    }
    const { configurations: defaultConfigurations, options: defaultOptions } = targetDefaults, defaults = tslib_1.__rest(targetDefaults, ["configurations", "options"]);
    const result = Object.assign(Object.assign({}, defaults), targetConfiguration);
    // Target is "compatible", e.g. executor is defined only once or is the same
    // in both places. This means that it is likely safe to merge options
    if (!targetDefaults.executor ||
        !targetConfiguration.executor ||
        targetDefaults.executor === targetConfiguration.executor) {
        result.options = Object.assign(Object.assign({}, defaultOptions), targetConfiguration === null || targetConfiguration === void 0 ? void 0 : targetConfiguration.options);
        result.configurations = mergeConfigurations(defaultConfigurations, targetConfiguration.configurations);
    }
    return result;
}
exports.mergeTargetConfigurations = mergeTargetConfigurations;
function mergeConfigurations(defaultConfigurations, projectDefinedConfigurations) {
    var _a, _b;
    const result = {};
    const configurations = new Set([
        ...Object.keys(defaultConfigurations !== null && defaultConfigurations !== void 0 ? defaultConfigurations : {}),
        ...Object.keys(projectDefinedConfigurations !== null && projectDefinedConfigurations !== void 0 ? projectDefinedConfigurations : {}),
    ]);
    for (const configuration of configurations) {
        result[configuration] = Object.assign(Object.assign({}, ((_a = defaultConfigurations === null || defaultConfigurations === void 0 ? void 0 : defaultConfigurations[configuration]) !== null && _a !== void 0 ? _a : {})), ((_b = projectDefinedConfigurations === null || projectDefinedConfigurations === void 0 ? void 0 : projectDefinedConfigurations[configuration]) !== null && _b !== void 0 ? _b : {}));
    }
    return result;
}
function resolveNxTokensInOptions(object, project, key) {
    const result = Array.isArray(object) ? [...object] : Object.assign({}, object);
    for (let [opt, value] of Object.entries(object !== null && object !== void 0 ? object : {})) {
        if (typeof value === 'string') {
            const workspaceRootMatch = /^(\{workspaceRoot\}\/?)/.exec(value);
            if (workspaceRootMatch === null || workspaceRootMatch === void 0 ? void 0 : workspaceRootMatch.length) {
                value = value.replace(workspaceRootMatch[0], '');
            }
            if (value.includes('{workspaceRoot}')) {
                throw new Error(`${logger_1.NX_PREFIX} The {workspaceRoot} token is only valid at the beginning of an option. (${key})`);
            }
            value = value.replace(/\{projectRoot\}/g, project.root);
            result[opt] = value.replace(/\{projectName\}/g, project.name);
        }
        else if (typeof value === 'object' && value) {
            result[opt] = resolveNxTokensInOptions(value, project, [key, opt].join('.'));
        }
    }
    return result;
}
exports.resolveNxTokensInOptions = resolveNxTokensInOptions;
function readTargetDefaultsForTarget(targetName, targetDefaults, executor) {
    if (executor) {
        // If an executor is defined in project.json, defaults should be read
        // from the most specific key that matches that executor.
        // e.g. If executor === run-commands, and the target is named build:
        // Use, use nx:run-commands if it is present
        // If not, use build if it is present.
        const key = [executor, targetName].find((x) => targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults[x]);
        return key ? targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults[key] : null;
    }
    else {
        // If the executor is not defined, the only key we have is the target name.
        return targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults[targetName];
    }
}
exports.readTargetDefaultsForTarget = readTargetDefaultsForTarget;
